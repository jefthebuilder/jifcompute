add <reg a> <reg b> <reg c>
sub <reg a> <reg b> <reg c>
<< <reg a > <reg b> <reg c>
>> <reg a > <reg b> <reg c>
mov <reg a> <reg b>
ld <high(1)/low(0)> <rega> <value>
lda <rega> <reg b> (loads at address stored in reg b)
sta <rega> <reg b> (loads at address stored in reg b)
equal <reg a> <reg b> <flag>
smaller <reg a> <reg b> <flag>
bigger <reg a> <reg b> <flag>
not <flag1> <None> <flag3>
and <flag1> <flag2> <flag3>
movf <flag1> <None> <flag3>
jmp (jumps at address stored in reg 8)
jmc <flag> (jumps at address stored in reg 8)
structure:
<instruction><rega/flag1><regb/flag2><regc/flag3><h/l><value>
      6 bit   3bit          3bit          3bit    1bit  16bit
the final instruction needs to be reversed
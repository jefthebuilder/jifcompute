add <reg a> <reg b> <reg c>
sub <reg a> <reg b> <reg c>
<< <reg a > <reg b> <reg c>
>> <reg a > <reg b> <reg c>
mov <reg a> <reg b> <reg c>
ld <high(1)/low(0)> <regc> <value>
lda <none> <reg b> <reg c> (loads at address stored in reg b)
sta <rega> <reg b> (stores at address stored in reg b)
equal <reg a> <reg b> <flag>
smaller <reg a> <reg b> <flag>
bigger <reg a> <reg b> <flag>
not <flag1> <None> <flag3>
and <flag1> <flag2> <flag3>
movf <flag1> <None> <flag3>
jmp (jumps at address stored in reg 8)
jmc <flag> (jumps at address stored in reg 8)
structure:
<value><h/l><regc/flag3><regb/flag2><rega/flag1><instruction>
16bit   1bit  3bit           3bit     3bit       6bit
the final instruction needs to be reversed